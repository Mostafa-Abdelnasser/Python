# -*- coding: utf-8 -*-
"""mv_ms_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q8S2YoR_3009t3rfJFi69j3C9mWUn4N5
"""

import tensorflow as tf

device_list = tf.test.gpu_device_name()

device_list

from keras.datasets import cifar100
from keras.models import Sequential
#cnn related
from keras.layers import Dense, Dropout, Conv2D, MaxPool2D, Flatten, Activation, Dropout
from keras.utils import np_utils
from tensorflow.keras.utils import to_categorical
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
import numpy as np
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.initializers import RandomNormal, Constant
# Loading the dataset
(x_train, y_train), (x_test, y_test) = cifar100.load_data()
# Check the shape of the array
print(f"×_train shape: {x_train.shape}")
print(f"y_train shape: {y_train.shape}")
print (f"x_test shape: {x_test.shape}")
print(f"y_test shape: {y_test.shape}")
# Number of samples in dataset
print(f"Train: {y_train.shape[0]}")
print(f"Test: {x_test.shape [0]}")
# Data format
print(type(x_train))
print(type(y_train))

plt.figure(figsize= (10, 10))
for i in range (16):
  rand_num = np.random. randint (0, 50000)
  cifar_img = plt.subplot (4,4, i+1)
  plt.imshow(x_train[rand_num])

#normalize image
train_images = x_train.astype('float32')/255
test_images = x_test.astype('float32')/255
print("Shape before one-hot encoding: ", y_train.shape)
# Transform labels to one hot encoding
train_labels = to_categorical(y_train)
test_labels = to_categorical (y_test)
print("Shape after one-hot encoding: ", train_labels.shape)

train_datagen = ImageDataGenerator (rotation_range=20, horizontal_flip=True)
X_train, X_validation, Y_train, Y_validation = train_test_split(train_images, train_labels)
train_datagen.fit(x_train)

model = Sequential ()

model. add(Conv2D(256, (3, 3) , padding= 'same', input_shape= (32, 32, 3)))
model.add(BatchNormalization())
model.add(Activation('relu'))
model.add(Conv2D (256, (3, 3) ,padding= 'same' ))
model.add(BatchNormalization ( ))
model.add(Activation('relu'))
model.add(MaxPool2D (pool_size=(2,2)))
model. add (Dropout (0.2))

model.add(Conv2D(512, (3,3),padding='same'))
model.add(BatchNormalization())
model.add(Activation('relu'))
model.add(Conv2D(512, (3,3),padding='same'))
model.add (BatchNormalization())
model.add(Activation('relu'))
model.add(MaxPool2D (pool_size=(2,2)))
model.add(Dropout (0.2))

model.add(Conv2D(512, (3,3),padding='same'))
model.add(BatchNormalization ())
model.add(Activation('relu'))
model.add(Conv2D(512, (3,3),padding='same'))
model.add(BatchNormalization ())
model.add(Activation('relu'))
model.add(MaxPool2D(pool_size=(2,2)))
model.add(Dropout (0.2))

model.add(Conv2D (512, (3,3),padding= 'same'))
model.add(BatchNormalization())
model.add(Activation('relu'))
model. add(Conv2D (512, (3, 3) , padding= 'same'))
model.add(BatchNormalization ( ))
model.add(Activation('relu'))
model.add(MaxPool2D(pool_size= (2,2)))
model. add(Dropout (0.2))

model. add(Conv2D (512, (3,3) ,padding= 'same' ))
model.add(BatchNormalization ( ))
model.add(Activation('relu'))
model.add(Conv2D(512, (3,3),padding='same'))
model.add(BatchNormalization ())
model.add(Activation('relu'))
model.add(MaxPool2D(pool_size= (2,2)))
model.add(Dropout (0.2))

model. add(Flatten ())
model. add(Dense(1024))
model.add(Activation('relu'))
model.add(Dropout (0.2))
model.add(BatchNormalization (momentum=0.95,
  epsilon=0.005,
  beta_initializer=RandomNormal (mean=0.0, stddev=0.05),
  gamma_initializer=Constant(value=0.9)))
model.add(Dense(100,activation='softmax'))
model.summary()

#from keras import optimizers
#import keras
from tensorflow.keras import optimizers
model.compile(loss='categorical_crossentropy',optimizer=optimizers.RMSprop(learning_rate=1e-5), metrics=['acc'] )

# Training model
import time
training_start = time.time()
history = model.fit(train_datagen.flow(X_train, Y_train, batch_size=100), steps_per_epoch=100,epochs=60,
          validation_data=(X_validation, Y_validation),
          verbose=1)
training_stop = time.time()
training_time = training_stop - training_start
print( f"Training time: {training_time}")

def plot (history):
  acc = history.history['acc']
  val_acc = history. history[ 'val_acc']
  loss = history.history['loss']
  val_loss = history.history[ 'val_loss']
  epochs = range(1, len(acc) + 1)
  plt.plot(epochs, acc, color='red'  , label='Training acc')
  plt.plot(epochs, val_acc, color='black', label= 'Validation acc')
  plt.title('Training and validation accuracy')
  plt.legend()
  plt.figure()
  plt.plot(epochs, loss, color='red', label='Training loss')
  plt.plot(epochs, val_loss, color='black', label='Validation loss')
  plt.title('Training and validation loss')
  plt.legend()
  plt.show()

# Visualize training process
plot(history)

#test models on testing data
scores = model.evaluate (test_images, test_labels)
print (f'accuracy on test set: {model.metrics_names [1]} of {scores [1]*100}')

# Translate categorial to array for drawing confusion matrix
from sklearn.metrics import confusion_matrix
from numpy import argmax
prediction = []
true_labels = []
pred = model.predict(test_images)
print(test_labels.shape[0])
for i in range(test_labels.shape[0]):
  prediction.append(argmax(pred[i]))
  true_labels.append(argmax(test_labels[i]))

cm = confusion_matrix(prediction, true_labels)

#Name of all classes in CIFAR-100
classes = ['beaver',
'dolphin', 'otter', 'seal', 'whale',
'aquarium' ,'fish', 'ray', 'shark', 'trout',
'orchids', 'poppies', 'roses', 'sunflowers', 'tulips',
'bottles','bowls', 'cans', 'cups', 'plates',
'apples','mushrooms', 'oranges', 'pears', 'sweet peppers',
'clock' , 'computer keyboard','bee'
'beetle','lamp','telephone' , 'television', 'bed', 'chair', 'cou'
'butterfly','caterpillar', 'cockroach','bear'
'leopard','lion', 'tiger','bridge'
'castle','house', 'road',
'wolf','skyscraper','cloud'
'forest','camel','mountain',
'cattle','plain','fox','chimpanzee','elephant','porcupine'
'possum', 'sea', 'kangaroo',
'crab','lobster','snail',
'raccoon','spider','skunk','worm','girl',
'baby', 'boy', 'dinosaur', 'lizard',
'man', 'woman',
'rocodile','mouse', 'rabbit', 'shrew','snake', 'turtle',
'hamster',
'squirrel',
'bicycle', 'bus', 'motorcycle', 'pickup truck', 'train',
'lawn-mower', 'rocket', 'streetcar', 'tank', 'tractor']

# Plot the confusion matrix
import matplotlib.pyplot as plt
print(cm)
fig = plt.figure(figsize= (20, 20))
ax = fig.add_subplot (211)
cax = ax.matshow(cm)
plt.title('Confusion matrix of the classifier')
fig.colorbar(cax)
ax.set_xticklabels([''] + classes)
ax.set_yticklabels([''] + classes)
pit.xlabel('Predicted')
plt.ylabel('True')
plt.show()

## Import the Library and functions you need
from sklearn.metrics import f1_score, accuracy_score, precision_score, recall_score
## Import the confusion_matrix function from the sklearn Library
from sklearn.metrics import confusion_matrix

#importing accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score


from sklearn.metrics import classification_report
print('\nClassification Report\n')
print(classification_report(prediction,true_labels, target_names=classes))

def predict_class():
  print(test_labels.shape[0])
  for i in range (0,16):
      print('Image '‚i)
      test = random.randint(0, 5000)
      prediction.append(argmax(pred[test]))
      true_labels.append(argmax(test_labels[test]))
      print('true label =' ,true_labels [i])
      print('predict_results= ' ,prediction[i])

predict_class()